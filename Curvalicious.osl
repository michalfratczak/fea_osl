// Curvalicious Shader - Screen Space Curvature Tools
// Curvalicious by Philippe Groarke
// Modified: 2022-04-23
// Copyright 2022 Autodesk Inc, All rights reserved. This file is licensed under Apache 2.0 license
//    https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt
//
// Implementation of screen space mean curvature from :
// Light Warping for Enhanced Surface Depiction
// Vergne et al.
//
// Romain Vergne, Romain Pacanowski, Pascal Barla, Xavier Granier, Christophe Schlick.
// Light Warping for Enhanced Surface Depiction.
// ACM Transactions on Graphics, Association for Computing Machinery, 2009, 28 (3), pp.25:1â€“25:8.
// ff10.1145/1531326.1531331ff. ffinria-00400829
// https://hal.inria.fr/inria-00400829


// x kernel (inverted)
// -1 0 1
// -2 0 2
// -1 0 1

// y kernel (inverted)
// -1 -2 -1
//  0  0  0
//  1  2  1

// (very) approximate sobel filter of input value.
// returns magnitude of gradient.
void sobel_filter(float c, output float gx, output float gy, output float mag, output float dir) {
	// get approximate neighbouring values :
	// tl t tr
	// l  c  r
	// bl b br
	float dx = Dx(c);
	float dy = Dy(c);

	float tl = c - dx + dy;
	float t = c + dy;
	float tr = c + dx + dy;
	float l = c - dx;
	float r = c + dx;
	float bl = c - dx - dy;
	float b = c - dy;
	float br = c + dx - dy;

	gx = -tl + tr - 2.0 * l + 2.0 * r - br + br;
	gy = -tl - 2.0 * t - tr + bl + 2.0 * b + br;
	mag = sqrt(gx * gx + gy * gy);
	dir = atan2(gy, gx);
}

shader Curvalicious
[[
	string help  =
		"<h3>Curvalicious</h3>"
		"Screen-space curvature tools.<br>"
		"Very fast curvature, edge, concave/convex approximation maps.<br>"
		"Caveats : False-positives at high angle fragments. Doesn't deal with hard edges."
		,
	string label = "Curvalicious"
]]
(
	float EdgeDetectStrength = 0.1
	[[
		string label = "Edge Detect - Strength",
		string help = "Increasing this value increases edge candidates for the colored edge map.",
		int connectable = 0
	]],

	float EdgeDetectGrayStrength = 0.1
	[[
		string label = "Edge Detect (Gray) - Strength",
		string help = "Increasing this value increases edge candidates for the grayscale edge map.",
		int connectable = 0
	]],

	output color Out = 0
	[[
		string help = "Edge Detect with convex edges blue, concave edges red."
	]],

	output color EdgeDetect = 0
	[[
		string label = "Edge Detect (Gray)",
		string help = "Typical edge detection output."
	]],

	output color ConcaveConvexTris = 0
	[[
		string label = "Concave/Convex Faces",
		string help = "Marks and colors concave (red) or convex (blue) faces."
	]]

	// output color OutDv = 0
	// [[
	// 	string help = ""
	// ]]
)
{
	vector posc = transform("camera", P);
	vector scale = filterwidth(posc);

	// Used to normalize our outputs to screen space scale.
	float pixel_scale = sqrt(scale[0] * scale[0] + scale[1] * scale[1]);

	// // sobel filter experiment
	// {
		
	// 	// Distance from camera plane.
	// 	float depth = -posc[2] / pixel_scale;

	// 	float gx, gy, gmag, gdir;
	// 	sobel_filter(depth, gx, gy, gmag, gdir);
	// 	Out = color(gx, gy, 0);
	// 	Out = gdir;
	// 	Out = rotate(vector(1,0,0), gdir, vector(0,0,1));
	// 	// return;

	// 	float depth_change = scale[2] / pixel_scale;
	// }


	vector n = transform("camera", N);
	float eps = 0.00001;
	float abs_n2 = abs(n[2]);
	int invalid = abs_n2 < eps;

	// Nice way to get ~ Sobel gradient, since Dx(Dx(v)) is undefined.
	float nz = invalid ? eps : abs_n2;
	float gx = -n[0] / nz;
	float gy = -n[1] / nz;

	// Modulate the gradient by the inverse of the
	// angle to the camera. Minimizes "false-positives"
	// for mesh shell.
	float angle_correction = invalid ? eps : abs_n2;

	// Gradient of gradient.
	float dgx = Dx(gx * angle_correction) / pixel_scale;
	float dgy = Dy(gy * angle_correction) / pixel_scale;

	// Edge Detect Gray
	{
		// Grayscale edge detect == approx sobel magnitude.
		EdgeDetect = sqrt(dgx * dgx + dgy * dgy) * EdgeDetectGrayStrength;
	}

	// Hessian
	float Ku = (gx + dgx) - (gx - dgx);
	float Kv = (gy + dgy) - (gy - dgy);
	float h = (Ku + Kv) / 2.0;

	// Concave / Convex Triangles
	{
		// Output helper map that marks concave or convex faces.
		if (abs(h) < 0.00001) {
			// Case near zero is invalid and can produce artifacting.
			ConcaveConvexTris = 0;
		} else {
			// blue = convex, red = concave
			ConcaveConvexTris = h < 0.0 ? color(0,0,1) : color(1,0,0);
		}
	}

	// Concave / Convex Edge Detect
	{
		float h2 = h * EdgeDetectStrength;
		color col;
		if (abs(h2) < eps) {
			col = 0;
		} else if (h2 < 0.0) {
			col = mix(color(0), color(0,0,1), -h2);
		} else {
			col = mix(color(0), color(1,0,0), h2);
		}
		Out = col;
	}
}

